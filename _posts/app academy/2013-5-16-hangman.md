---
layout: post
tagline: "App Academy W1D4"
tags : [app academy]
---

### Hangman

After yesterday's exhausting day today was more of a time to sit down and gathering one's self in preparation for tomorrow when we talk about nodes and trees. Those I expect are going to be mighty challenging so I am going to have to work pretty hard in my preparation. We also learned about the rigorous assessments that we are going to have to take on Monday. If we fail 2 of them, we are asked to leave the program. Supposedly the dropoff rate was pretty big last year. I hope to stay afloat for the next 8 weeks!

Today's big learning opportunity was in a big project that is called Hangman. The prompt basically asked us to create together a program that lets you play Hangman with a computer or human friend. The parameters were:

The program imports a dictionary file that we provide.

We tell the computer how many human players are playing. If it is less than two then the computer goes and fills in the rest of the roster with computer players

We as players get to choose if we want to be the one picking or guessing the words

Then the program either helps facilitate the game or if we have chosen two computers playing against one another then they compete until the end without input from myself. I found it a delightful challenge to put it together.

Three Things I Learned Today:

In my attempt to understand recursion better, I started to get a better sense of what is going on when a recursion call and what happens in the "stack level goes too deep" error message.

Many times I am working with one eye on helping to test the program and too often I am defaulting to certain things to make it easier to run a program from the terminal. Examples include hard-coding the name of the dictionary file to be passed into Hangman. This is bad for debugging if someone else is looking at the code. Creating a library and a number of presets might at first be a hassle but can result in more modular and easily understandable methods and overall better code.

Spending a little time thinking hard on what a program can do saves a lot of time

